using GoToIt.Constants;
using GoToIt.Extensions;
using GoToIt.Filters;
using GoToIt.Logging;
using GoToIt.Primitives;
using GoToIt.Utilities;
using GoToIt.Windows;
using Microsoft.CodeAnalysis;
using Microsoft.VisualStudio;
using Microsoft.VisualStudio.OLE.Interop;
using Microsoft.VisualStudio.Text.Editor;
using Microsoft.VisualStudio.TextManager.Interop;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;

namespace GoToIt.Commands
{
    /// <summary>
    /// Handles the Query/Exec commands from Visual Studio.
    /// </summary>
    /// <seealso cref="Microsoft.VisualStudio.OLE.Interop.IOleCommandTarget" />
    /// <seealso cref="System.IDisposable" />
    public class CommandTarget : IOleCommandTarget, IDisposable
    {
        private readonly IOleCommandTarget _nextTarget;
        private readonly ITextView _textView;
        private readonly IDocumentNavigationService _navigationService;
        private readonly FindSymbolTarget _goToGenericArgumentsCommand = new FindSymbolTarget(WhereGenericArgumentFilter.Instance.IsMatch);
        private readonly FindSymbolTarget _goToMethodArgumentsCommand = new FindSymbolTarget(WhereMethodArgumentFilter.Instance.IsMatch);
        private readonly SingleCancellationTokenSource _tokenSource = new SingleCancellationTokenSource();
        private readonly FindAllReferencesWindow _window;

        /// <summary>
        /// Initializes a new instance of the <see cref="CommandTarget"/> class.
        /// </summary>
        /// <param name="viewAdapter">The view adapter.</param>
        /// <param name="textView">The text view.</param>
        /// <param name="navigationService">The navigation service.</param>
        /// <param name="window">The window.</param>
        public CommandTarget(IVsTextView viewAdapter, ITextView textView, IDocumentNavigationService navigationService, FindAllReferencesWindow window) {
            _textView = textView;
            _navigationService = navigationService;
            _window = window;            

            viewAdapter.AddCommandFilter(this, out _nextTarget);
        }

        /// <summary>
        /// Queries the object for the status of one or more commands generated by user interface events.
        /// </summary>
        /// <param name="pguidCmdGroup">The GUID of the command group.</param>
        /// <param name="cCmds">The number of commands in <paramref name="prgCmds" />.</param>
        /// <param name="prgCmds">An array of <see cref="T:Microsoft.VisualStudio.OLE.Interop.OLECMD" /> structures that indicate the commands for which the caller needs status information. This method fills the <paramref name="cmdf" /> member of each structure with values taken from the <see cref="T:Microsoft.VisualStudio.OLE.Interop.OLECMDF" /> enumeration.</param>
        /// <param name="pCmdText">An <see cref="T:Microsoft.VisualStudio.OLE.Interop.OLECMDTEXT" /> structure in which to return name and/or status information of a single command. This parameter can be null to indicate that the caller does not need this information.</param>
        /// <returns>
        /// This method returns S_OK on success. Other possible return values include the following.Return codeDescriptionE_FAILThe operation failed.E_UNEXPECTEDAn unexpected error has occurred.E_POINTERThe <paramref name="prgCmds" /> argument is null.OLECMDERR_E_UNKNOWNGROUPThe <paramref name="pguidCmdGroup" /> parameter is not null but does not specify a recognized command group.
        /// </returns>
        public int QueryStatus(ref Guid pguidCmdGroup, uint cCmds, OLECMD[] prgCmds, IntPtr pCmdText) {
            if (pguidCmdGroup == Signatures.CmdSetGuid) {
                if (prgCmds.TryFirstIndex(x => x.cmdID == (uint)IdSymbol.IdSymbolMenuGoTo, out var index)) {
                    //The item under the cursor must be searchable to see the menu

                    var node = _textView.GetNodeUnderCursor();
                    Telemetry.WriteEvent($"Checking if the node {node} is searchable.");

                    var isVisible = node.IsSearchable();
                    prgCmds.SetVisible(index, isVisible);
                    Telemetry.WriteTrace($"'Go To' menu is {(isVisible ? "visible" : "not visible")}");
                    
                    return Microsoft.VisualStudio.VSConstants.S_OK;
                }                
            }

            return _nextTarget.QueryStatus(ref pguidCmdGroup, cCmds, prgCmds, pCmdText);
        }

        /// <summary>
        /// Executes the specified command.
        /// </summary>
        /// <param name="pguidCmdGroup">The GUID of the command group.</param>
        /// <param name="nCmdID">The command ID.</param>
        /// <param name="nCmdexecopt">Specifies how the object should execute the command. Possible values are taken from the <see cref="T:Microsoft.VisualStudio.OLE.Interop.OLECMDEXECOPT" /> and <see cref="T:Microsoft.VisualStudio.OLE.Interop.OLECMDID_WINDOWSTATE_FLAG" /> enumerations.</param>
        /// <param name="pvaIn">The input arguments of the command.</param>
        /// <param name="pvaOut">The output arguments of the command.</param>
        /// <returns>
        /// This method returns S_OK on success. Other possible return values include the following.Return codeDescriptionOLECMDERR_E_UNKNOWNGROUPThe <paramref name="pguidCmdGroup" /> parameter is not null but does not specify a recognized command group.OLECMDERR_E_NOTSUPPORTEDThe <paramref name="nCmdID" /> parameter is not a valid command in the group identified by <paramref name="pguidCmdGroup" />.OLECMDERR_E_DISABLEDThe command identified by <paramref name="nCmdID" /> is currently disabled and cannot be executed.OLECMDERR_E_NOHELPThe caller has asked for help on the command identified by <paramref name="nCmdID" />, but no help is available.OLECMDERR_E_CANCELEDThe user canceled the execution of the command.
        /// </returns>
        /// <exception cref="NotImplementedException"></exception>
        public int Exec(ref Guid pguidCmdGroup, uint nCmdID, uint nCmdexecopt, IntPtr pvaIn, IntPtr pvaOut) {
            if (pguidCmdGroup == Signatures.CmdSetGuid) {

                if (nCmdID == (uint)IdSymbol.CommandGoToGeneric) {
                    return DoNodeSearch(_goToGenericArgumentsCommand);

                } else if (nCmdID == (uint)IdSymbol.CommandGoToMethod) {
                    return DoNodeSearch(_goToMethodArgumentsCommand);

                } else {
                    throw new NotImplementedException();
                }
            }

            return _nextTarget.Exec(ref pguidCmdGroup, nCmdID, nCmdexecopt, pvaIn, pvaOut);
        }

        /// <summary>
        /// Searches for nodes using the specified search command.
        /// </summary>
        /// <param name="cmd">The command.</param>
        /// <returns></returns>
        private int DoNodeSearch(FindSymbolTarget cmd) {
            Telemetry.WriteEvent($"Searching using {cmd}");

            var node = _textView.GetNodeUnderCursor();
            if (node != null) {
                var doc = _textView.GetCursorPosition().GetDocument();
                var model = doc.GetSemanticModel();
                var symbol = model.GetDeclaredSymbol(node);

                var bag = new ConcurrentBag<IEnumerable<SearchResult>>();
                var token = _tokenSource.Next();

                cmd.FindAllReferences(symbol, doc.Project.Solution, bag, token);

                _window.Load(bag, token);
            }

            return Microsoft.VisualStudio.VSConstants.S_OK;
        }

        public void Dispose() {
            Dispose(true);
        }

        protected virtual void Dispose(bool disposing) {
            if (disposing) {
                _tokenSource.Dispose();
            }
        }

    }
}
